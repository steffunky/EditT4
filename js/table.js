// Generated by CoffeeScript 1.9.3
// file unchanged (same content as EditT3) 
(function() {
  window.Table = (function() {
    function Table() {
      this.$table = $('<table></table>');
      this.$elementSelected = [];
      this.columnNumber = 0;
      this.lineNumber = 0;
      this.mouseDown = false;
      this.$table.on({
        tableBuilt: (function(_this) {
          return function() {
            return _this.tableChanged();
          };
        })(this),
        rowCreated: (function(_this) {
          return function() {
            return _this.tableChanged();
          };
        })(this),
        headerCellCreated: (function(_this) {
          return function() {
            return _this.tableChanged();
          };
        })(this)
      });
    }

    // Create and return a line
    Table.prototype.createLine = function() {
      return $('<tr></tr>');
    };

    // Create and return a head cell.
    // If $button is specified, the cell appends this button instead of the text
    Table.prototype.createHeadCell = function(text, column, $button) {
      var $content, $element;
      $element = $('<th></th>').addClass('column dropper').attr('dropzone', 'move');
      // The first column of the header shouln't be draggable
      if (column === 0) {
        $element.attr('draggable', 'false');
      } else {
        $element.addClass('draggable').attr('draggable', 'true');
      }
      $content = $('<div></div>').addClass('content');
      if (($button != null)) {
        $content.append($button);
      } else {
        $content.text(text);
      }
      $element.append($content);
      return $element;
    };

    // Create a cell
    // draggable, dropper and content are optionals
    Table.prototype.createCell = function(column, draggable, dropper, content) {
      var $element;
      $element = $('<td></td>');
      if (column === 0) {
        $element.addClass('row');
      } else {
        $element.addClass('cell');
        this.applyCellSelectEvents($element);
      }
      if (draggable) {
        $element.addClass('draggable').attr('draggable', 'true');
      }
      if (dropper) {
        $element.addClass('dropper');
      }
      if (content) {
        $element.append(content);
      }
      return $element;
    };

    // Build the header
    Table.prototype.buildHeader = function() {
      var $button, $element, $line;
      $line = this.createLine();
      $button = $('<div></div>').addClass('add_row').text('Add row');
      $button.on({
        click: (function(_this) {
          return function() {
            return _this.addRow();
          };
        })(this)
      });
      
      // The first column of the header shouln't be draggable
      $element = $('<th></th>').addClass('add_row column row dropper').append($button);
      $element.attr({
        draggable: 'false',
        dropzone: 'move'
      });
      $line.append($element);
      this.$table.append($line);
      this.columnNumber = 1;
      return this.lineNumber = 1;
    };

    // Returns the table node
    Table.prototype.getTableNode = function() {
      return this.$table;
    };

    // Starts from 1
    // This returns the visually column number
    Table.prototype.getNumColumn = function($cell) {
      var index, total, total_of_line;
      // Maybe the line is splitted
      index = $cell.index() + 1;
      total_of_line = $cell.parent('tr').find('td').length;
      total = this.columnNumber;
      return total - total_of_line + index;
    };

    // Broken. Should be used by moveColumn (broken too)
    Table.prototype.getColumn = function(column) {
      return this.$table.find("tr th:nth-child(" + column + "), tr td:nth-child(" + column + ")");
    };

    // Create a new item in $dest
    // $src is the original element, $src_copy a copy of the $src and $dest is... the destination
    Table.prototype.createItem = function($src_copy, $dest) {
      var $new_src;
      $new_src = $dest.append($src_copy);
      return this.$table.trigger('itemCreated', [$new_src]);
    };

    // Move an item to the destination
    // $src is the original element, $src_copy a copy of the $src and $dest is... the destination
    Table.prototype.moveItem = function($src, $src_copy, $dest) {
      $dest.append($src_copy);
      $src.trigger('itemMoved', [$src_copy]);
      return $src.remove();
    };

    // src and dest should be <tr>
    Table.prototype.moveRow = function($src, $src_copy, $dest) {
      var $elem, $new_dest, $next, $row, $temp, $tr, elem, i, k, l, len, len1, m, n, new_elements, ref, ref1, ref2, ref3, ref4, results, rowspan_dest, rowspan_src;
      rowspan_src = (ref = $src.children().eq(0).attr('rowspan')) != null ? ref : 1;
      rowspan_dest = (ref1 = $dest.children().eq(0).attr('rowspan')) != null ? ref1 : 1;
      $new_dest = $dest;
      for (i = k = 1, ref2 = rowspan_dest - 1; k <= ref2; i = k += 1) {
        $new_dest = $new_dest.next();
      }
      $new_dest = $src_copy.insertAfter($new_dest);
      
      // We'll need to reapply events on these elements
      new_elements = [$new_dest];
      $next = $src.next();
      $src.remove();
      
      for (i = l = 1, ref3 = rowspan_src - 1; l <= ref3; i = l += 1) {
        $new_dest = $next.clone().insertAfter($new_dest);
        new_elements.push($new_dest);
        $temp = $next.next();
        $next.remove();
        $next = $temp;
      }

      results = [];
      // Re apply the events on the new cells
      for (m = 0, len = new_elements.length; m < len; m++) {
        $tr = new_elements[m];
        $row = $tr.find('.row');
        this.$table.trigger('rowMoved', [$row]);
        ref4 = $tr.find('td');
        
        for (n = 0, len1 = ref4.length; n < len1; n++) {
          elem = ref4[n];
          $elem = $(elem);
          this.applyCellSelectEvents($elem);
          this.$table.trigger('cellMoved', [$elem]);
        }
        results.push((function() {
          var len2, o, ref5, results1;
          ref5 = $tr.find('.item');
          results1 = [];
          
          // reapply drag events to the items
          for (o = 0, len2 = ref5.length; o < len2; o++) {
            elem = ref5[o];
            results1.push(this.$table.trigger('itemMoved', [$(elem)]));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    // TODO : Broken. Should move columns
    Table.prototype.moveColumn = function($src, $src_copy, $dest) {
      var $elements_dest, $elements_src, column_dest, column_src, i, k, ref, results;
      column_src = this.getNumColumn($src);
      column_dest = this.getNumColumn($dest);
      
      // Same columns, quit
      if (column_src === column_dest) {
        return;
      }

      // Insert each cell of the column after each cell of the target column
      $elements_src = this.getColumn(column_src);
      $elements_dest = this.getColumn(column_dest);
      
      // Start with the header
      $src = $elements_src.eq(0);
      $src_copy = $src.clone();
      $dest = $elements_dest.eq(0);
      
      $src_copy.insertAfter($dest);
      this.$table.trigger('headerCellMoved', [$src_copy]);
      
      $src.remove();
      
      results = [];
      // Cells (not draggable)
      for (i = k = 1, ref = $elements_src.length - 1; k <= ref; i = k += 1) {
        $src = $elements_src.eq(i);
        $src_copy = $src.clone();
        $dest = $elements_dest.eq(i);
        $src_copy.insertAfter($dest);
        this.$table.trigger('cellMoved', [$src_copy]);
        $src_copy.find('.item').each((function(_this) {
          return function(i, elem) {
            return $src.trigger('itemMoved', [$(elem)]);
          };
        })(this));
        results.push($src.remove());
      }
      return results;
    };

    // Return false if the elements can be splitted in n_splits
    Table.prototype.checkIfNotSplittable = function($element, n_splits) {
      var $td, $tr, i, k, n_line, nb_cells, ref, rowspan;
      // An element is splittable in n_splits cells if at the rest of the line there is n_splits * i lines
      // For example, if we have 6 lines after our cell, we can split it in 2, 3 or 6
      n_line = parseInt($element.attr('rowspan'));
      if (!n_line) {
        n_line = 1;
      }
      // If the right part is not splitted, the cell can always be splitted
      if (n_line === 1) {
        return false;
      }

      nb_cells = 1;

      // Count how many cells there is on the right part
      $tr = $element.closest('tr');
      $td = $element.next();
      rowspan = $td.attr('rowspan') || 1;
      n_line -= rowspan;
      while (n_line !== 0) {
        for (i = k = 0, ref = rowspan - 1; k <= ref; i = k += 1) {
          $tr = $tr.next();
        }
        rowspan = $tr.find('td:nth-child(1)').attr('rowspan') || 1;
        n_line -= rowspan;
        nb_cells += 1;
      }
      if (nb_cells % n_splits === 0) {
        return false;
      }
      return true;
    };

    // Split a cell which have a rowspan
    Table.prototype.splitCellWithRowspan = function($element, n_splits, rowspan) {
      var $cell, $tr, i, k, new_rowspan, ref, ref1, ref2, results;
      new_rowspan = rowspan / n_splits;
      $element.attr('rowspan', new_rowspan);
      $tr = $element.closest('tr').nextAll('tr');
      results = [];
      for (i = k = ref = new_rowspan - 1, ref1 = rowspan - 2, ref2 = new_rowspan; ref2 > 0 ? k <= ref1 : k >= ref1; i = k += ref2) {
        $cell = this.createCell(1, false, true).attr('rowspan', new_rowspan);
        results.push($tr.eq(i).prepend($cell));
      }
      return results;
    };

    // Split a cell which doesn't have a rowspan
    Table.prototype.splitCellWithNoneRowspan = function($element, n_splits) {
      var $cell, $cells, $new_tr, $prev, $tr, i, i_merge, j, k, l, min_cells_to_have, new_num_column, num_column, number_of_cells_to_merge, number_of_cells_to_split, ref, ref1, rowspan, rowspan_attribute;
      if (!$element.hasClass('cell')) {
        return;
      }
      num_column = this.getNumColumn($element);
      // Number of cells in this line
      // + 2 because we add the cell on which we clicked, and the row's number column
      number_of_cells_to_split = this.columnNumber - num_column + 1;
      // Number of cells to merge
      number_of_cells_to_merge = this.columnNumber - number_of_cells_to_split;
      
      // + 2 because we add the cell on which we clicked, and the row's number column
      $tr = $element.parent('tr');
      // -1 because when we split in 3 for example, we just add 2 lines
      for (i = k = 0, ref = n_splits - 2; k <= ref; i = k += 1) {
        // We create a new line
        $new_tr = $('<tr></tr>');
        
        // Add a new cell from where we clicked to the end of the line
        for (j = l = 0, ref1 = number_of_cells_to_split - 1; l <= ref1; j = l += 1) {
          new_num_column = num_column + j;
          $cell = this.createCell(new_num_column, false, true);
          this.$table.trigger('cellMoved', [$cell]);
          $new_tr.append($cell);
        }
        $new_tr.insertAfter($tr);
      }
      
      // Have to merge to_merge cells which are before the cell we splitted
      $prev = $element.prev();
      // Index on which cell we work
      i_merge = number_of_cells_to_merge - 1;
      while (i_merge !== -1) {
        while ($prev.length === 0) {
          $tr = $tr.prev();
          if ($tr.length === 0) {
            console.err('Error when splitting cell');
            return;
          }
          $cells = $tr.find('td');
          // Check if it is our cell
          min_cells_to_have = number_of_cells_to_split + (number_of_cells_to_merge - i_merge);
          if ($cells.length > min_cells_to_have) {
            $prev = $cells.eq(i_merge);
          }
        }
        rowspan = n_splits;
        // If the cell has ever been merged with another line, add 1 to the actual rowspan
        rowspan_attribute = $prev.attr('rowspan');
        if (rowspan_attribute) {
          // -1 because when we split in 2 cell (for example), this add only 1 cell
          // so n_splits - 1
          rowspan = parseInt(rowspan_attribute, 10) + parseInt(n_splits, 10) - 1;
        }
        $prev.attr('rowspan', rowspan);
        i_merge -= 1;
        $prev = $prev.prev();
      }
    };

    // Split a cell in n_splits (call splitCellWithRowspan or splitCellWithNoneRowspan)
    Table.prototype.splitCell = function($element, n_splits) {
      var rowspan;
      rowspan = $element.attr('rowspan');
      if (rowspan && rowspan > 1) {
        return this.splitCellWithRowspan($element, n_splits, rowspan);
      } else {
        return this.splitCellWithNoneRowspan($element, n_splits);
      }
    };

    // Return false if the elements are mergeable
    Table.prototype.checkIfNotMergeable = function($elements) {
      var $element, $first_parent_cell, $parent_cell, $parent_line, column, i, j, k, l, m, ref, ref1, ref2;
      // Mergeable only if this is the same column
      column = this.getNumColumn($elements.eq(0));
      for (i = k = 1, ref = $elements.length - 1; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        if (this.getNumColumn($elements.eq(i)) !== column) {
          return true;
        }
      }
      
      // The elements should have the same parent
      $first_parent_cell = null;
      for (i = l = 0, ref1 = $elements.length - 1; l <= ref1; i = l += 1) {
        $element = $elements.eq(i);
        $parent_cell = $element.prev();
        if ($parent_cell.length === 0) {
          // Get the first line
          $parent_line = $element.closest('tr');
          for (j = m = 0, ref2 = i - 1; m <= ref2; j = m += 1) {
            $parent_line = $parent_line.prev();
          }
          // -2 because getNumColumn starts from 1 and we want the previous one
          $parent_cell = $parent_line.find('td').eq(column - 2);
        }
        if ($first_parent_cell !== null && $parent_cell.is($first_parent_cell) === false) {
          return true;
        }
        $first_parent_cell = $parent_cell;
      }
      return false;
    };

    // If not mergeables, the result is undetermined
    // $elements should be at the order top ----> bottom
    Table.prototype.mergeCells = function($elements) {
      var $first_element, $previous_element, $save_items, $to_save_element, actual_rowspan, i, j, k, length, ref, results;
      $save_items = [];
      length = $elements.length;
      $first_element = $elements.eq(0);
      if (length <= 1) {
        return;
      }
      $save_items = [];
      // Remove the lines we merged
      for (i = k = 1, ref = length - 1; k <= ref; i = k += 1) {
        $to_save_element = $elements.eq(i);
        j = 0;
        while (true) {
          if ($save_items[j] == null) {
            $save_items[j] = [];
          }
          $save_items[j].push($to_save_element.find('.item'));
          $to_save_element = $to_save_element.next();
          j++;
          if ($to_save_element.length === 0) {
            break;
          }
        }
        $elements.eq(i).parent('tr').remove();
      }
      // Reduce the previous cells
      $previous_element = $first_element.prev();
      while ($previous_element.length !== 0) {
        actual_rowspan = $previous_element.attr('rowspan') || 1;
        $previous_element.attr('rowspan', actual_rowspan - length + 1);
        $previous_element = $previous_element.prev();
      }
      j = 0;
      results = [];
      while (true) {
        $first_element.append($save_items[j]);
        $first_element = $first_element.next();
        if ($first_element.length === 0) {
          break;
        }
        results.push(j++);
      }
      return results;
    };

    // Trigger an evenment
    Table.prototype.tableChanged = function() {
      return this.$table.trigger('tableChanged');
    };

    // Build the table
    Table.prototype.buildTable = function() {
      this.$table.addClass('resizable');
      this.buildHeader();
      return this.$table.trigger('tableBuilt');
    };

    // Add a new row
    Table.prototype.addRow = function() {
      var $cell, $delete, $header_cell, $line, j, k, ref;
      $line = this.createLine();
      // Delete the row button
      $delete = $('<span></span>').addClass('span_action glyphicon glyphicon-remove');
      $delete.on({
        click: (function(_this) {
          return function(event) {
            var $elem, $next, $temp, $tr, i, k, ref, ref1, rowspan;
            $elem = $(event.currentTarget);
            $tr = $elem.closest('tr');
            rowspan = (ref = $tr.children().eq(0).attr('rowspan')) != null ? ref : 1;
            $next = $tr.next();
            $tr.find('.item').trigger('toRemove');
            $tr.remove();
            for (i = k = 1, ref1 = rowspan - 1; k <= ref1; i = k += 1) {
              $temp = $next.next();
              $next.find('.item').trigger('toRemove');
              $next.remove();
              $next = $temp;
            }
            return _this.lineNumber -= 1;
          };
        })(this)
      });
      $header_cell = this.createCell(0, true, true, $delete);
      $line.append($header_cell);
      this.$table.trigger('headerCellCreated', [$header_cell]);
      for (j = k = 2, ref = this.columnNumber; k <= ref; j = k += 1) {
        $cell = this.createCell(j, false, true);
        $line.append($cell);
        this.$table.trigger('cellCreated', [$cell]);
      }
      this.$table.append($line);
      this.lineNumber += 1;
      return this.$table.trigger('rowCreated', [$line]);
    };

    // Add a new column with the according name
    Table.prototype.addColumn = function(name) {
      var $cell, $header, $trs, i, k, ref;
      $header = this.createHeadCell(name, this.columnNumber);
      $trs = this.$table.find('tr');
      $trs.eq(0).append($header);
      for (i = k = 1, ref = $trs.length - 1; k <= ref; i = k += 1) {
        $cell = this.createCell(i, false, true);
        $trs.eq(i).append($cell);
        this.$table.trigger('cellCreated', [$cell]);
      }
      this.columnNumber += 1;
      return this.$table.trigger('headerCellCreated', [$header]);
    };

    Table.prototype.setMouseDown = function(state) {
      return this.mouseDown = state;
    };

    Table.prototype.getHeaderCellContent = function($cell) {
      var col;
      col = this.getNumColumn($cell) - 1;
      return this.$table.find('th').eq(col).find('.content').text();
    };

    Table.prototype.findCell = function(line, column) {
      return this.$table.find("tr:nth-child(" + line + ") th:nth-child(" + column + "), tr:nth-child(" + line + ") td:nth-child(" + column + ")");
    };

    Table.prototype.getLineNumber = function() {
      return this.lineNumber;
    };

    Table.prototype.clear = function() {
      this.$table.empty();
      return this.buildTable();
    };

    Table.prototype.applyCellSelectEvents = function($element) {
      // Events
      return $element.on({
        mouseover: (function(_this) {
          return function(e) {
            if (_this.mouseDown === true) {
              return $element.addClass('selected');
            }
          };
        })(this),
        mousedown: (function(_this) {
          // If it is the right click...
          return function(e) {
            var has_class;
            if (e.which === 3) {
              if ($element.hasClass('selected') === false) {
                if (!e.ctrlKey) {
                  $('.selected').removeClass('selected');
                }
                return $element.addClass('selected');
              }
            } else {
              if (e.ctrlKey) {
                return $element.toggleClass('selected');
              } else {
                has_class = $element.hasClass('selected');
                $('.selected').removeClass('selected');
                // If the element didn't have the class, just add it
                if (!has_class) {
                  return $element.addClass('selected');
                }
              }
            }
          };
        })(this)
      });
    };

    return Table;

  })();

}).call(this);
